<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script>
    function Pointor(name,age){
        this.name=name;
        this.age=age;
    }
    Pointor.prototype.say=function(){
        console.log(this.name+"说终于有类了");
    };
    var sj=new Pointor("书俊","22");
    sj.say();
    class Pointer{
        constructor(x,y){   /*constructor 关键字 不能换*/
            this.x=x;
            this.y=y;
        }
        say(){  /*say 函数名 随意起*/
            console.log(this.x+"说终于有类了");
        }
    }

    var jx=new Pointer("嘉祥","21");/* 必须有new */

    jx.say();

    console.log(Pointor.name);//返回pointer 即 返回紧跟在class后面的类名
//     class不存在变量名提升 不能先调用在定义 否则会报错
//    类的继承
//    class之间可以通过extends关键字继承
    class Col extends Pointer{};
    /*上面的代码定义了一个ColorPointer类 该类通过extends关键字，继承了pointer类的所有属性和方法 但是由于没有部署任何代码 所以这两个类完全一样 等于复制了一个*/
    var ff=new Col("jiaxiang");
    ff.say();


    class aaa extends Pointer{
        constructor(x,y,color){
            super(x,y);  //调用父类的constructor(x,y)
            this.color=color;
        }
        sayHi(){
        console.log(this.color+"HI!!");   //添加了this关键字
    }
    };
    var mm=new aaa("x","y","ypz");
    mm.sayHi();
    //在子类的构造函数中 只有调用super之后 才能使用this关键字，否则会报错 是因为子类实例的构建是基于对父类实际加工 只有super方法才能返回父类实例
</script>
</body>
</html>